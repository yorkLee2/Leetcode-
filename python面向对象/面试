1.GIL：
全称Global Interpreter Lock为了避免误导.
Python当然也逃不开，为了利用多核，Python开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。 
于是有了GIL这把超级大锁，而当越来越多的代码库开发者接受了这种设定后，他们开始大量依赖这种特性（即默认python内部对象是thread-safe的，无需在实现时考虑额外的内存锁和同步操作）

2.深拷贝和浅拷贝的区别
深拷贝就是完全跟以前就没有任何关系了，原来的对象怎么改都不会影响当前对象，可以理解为两者离婚了。
浅拷贝就是原对象的list元素改变的话会改变当前对象，如果当前对象中list元素改变了，也同样会影响原对象。藕断丝连

Python垃圾回收机制:
第一层Layer1的仅仅是对malloc的简单包装，raw memory，目的是为了兼容各个操作系统，因为不同的操作系统调用malloc的时候可能会有不同的行为结果
第二层Layer2是内存管理机制的核心，其中gc就是在这一层发挥至关重要的作用
第三层：是对象缓冲池，如python对一些对象的直接操作，包括int，list等。 
对于可能被经常使用、而且是immutable的对象，如bool类型，元祖类型，小的整数、长度较短的字符串等，python会缓存在layer3，直接供python调用，避免频繁创建和销毁。
Python为了避免频繁的申请和删除内存所造成系统切换于用户态和核心态的开销，从而引入了内存池机制，专门用来管理小内存的申请和释放。
整个小块内存的内存池可以视为一个层次结构，其一共分为4层，从下之上分别是block、pool、arena和内存池。
需要说明的是：block、pool和area都是代码中可以找到的实体，而最顶层的内存池只是一个概念上的东西，表示Python对于整个小块内存分配和释放行为的内存管理机制。
  Python中，主要通过引用计数（Reference Counting）进行垃圾回收。
  在引用计数的基础上，还可以通过“标记－清除”解决容器对象可能产生的循环引用的问题。通过分代回收以空间换取时间进一步提高垃圾回收的效率。
 
引用计数法有其明显的优点，如高效、实现逻辑简单、具备实时性，一旦一个对象的引用计数归零，内存就直接释放了。不用像其他机制等到特定时机。
将垃圾回收随机分配到运行的阶段，处理回收内存的时间分摊到了平时，正常程序的运行比较平稳。但是，引用计数也存在着一些缺点，通常的缺点有：
  1.逻辑简单，但实现有些麻烦。每个对象需要分配单独的空间来统计引用计数，这无形中加大的空间的负担，并且需要对引用计数进行维护，在维护的时候很容易会出错。
  2.在一些场景下，可能会比较慢。正常来说垃圾回收会比较平稳运行，但是当需要释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间。
  3. 循环引用。这将是引用计数的致命伤，引用计数对此是无解的，因此必须要使用其它的垃圾回收算法对其进行补充。
 
