进程:
正在执行中的应用程序，一个进程是一个执行中的文件使用资源的总和，属于动态概念，包括虚拟地址空间，代码，数据，对象句柄，环境变量，执行单元等。
多进程应该避免共享资源。
进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的
多线程的主要作用：充分利用硬件资源，尤其是提高CPU利用率
进程间的数据交换使用Queue对象在进程间交换数据，一个进程把数据放入Queue对象，另一个进程从Queue对象中获取数据。

缺点：
1.进程只能在一个时间干一件事. 2.进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。
如果把我们上课的过程看成一个进程的话，听老师讲课，记笔记，脑子还要思考问题。 上面这三件事将不能同时执行，同一时间只能做一件事.

from multiprocessing import Process, Queue
    multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。
此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。
所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。


Procss构造方法：
Process([group [, target [, name [, args [, kwargs]]]]])
　　group: 线程组，目前还没有实现，库引用中提示必须是None； 
　　target: 要执行的方法； 
　　name: 进程名； 
　　args/kwargs: 要传入方法的参数。

实例方法：
　　is_alive()：返回进程是否在运行。
　　join([timeout])：阻塞当前上下文环境的进程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。
　　start()：进程准备就绪，等待CPU调度
　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。
　　terminate()：不管任务是否完成，立即停止工作进程

from multiprocessing import Process
import time
def f(name):
    time.sleep(1)
#time.sleep用于给定时间内挂起(等待)当前线程的执行
#time.sleep通常用于推迟执行的场景
    print('hello', name, time.ctime())

if __name__== '__main__':
    p_list=[]
    for i in range(3):
        p = Process(target=f, args=('alvin',))
        p_list.append(p)            #添加
        p.start()
    for i in p_list:
        p.join()
    print('end')


###########output:
Connected to pydev debugger (build 183.6156.16)
hello alvin Wed Dec 14 16:16:47 2022
hello alvin Wed Dec 14 16:16:48 2022
hello alvin Wed Dec 14 16:16:49 2022
end



from  multiprocessing import Process
import os

def f(name):
  print('module name:', __name__)
#查看父类进程ID
#pid:进程号
  print('parent process',  os.getppid())
  print('process id:', os.getpid())

if __name__=='__main__':
  p=Process(target=f,args=('bob',))
  p.start()    #启动线程
  p.join()     #等待进程运行结束

########output




线程 Threads: 上述进程缺点让我们引入线程这种机制。
解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。

线程调用的两种方法：
1.直接使用Thread类实例化一个线程对象并传递一个可调用对象作为参数
2.继承Tread类并在派生类重写__init__()和run()方法。
import threading
import time
　　
class MyThread(threading.Thread):
    def __init__(self,num):
        threading.Thread.__init__(self)
        self.num = num
 
    def run(self):#定义每个线程要运行的函数
 
        print("running on number:%s" %self.num)
 
        time.sleep(3)
 
if __name__ == '__main__':
 
    t1 = MyThread(1)
    t2 = MyThread(2)
    t1.start()
    t2.start()

########output:
running on number:1
running on number:2


from threading import Thread
import time
def func1(x, y):
    for i in range(x, y):
        print(i, end='')
    print()
    time.sleep(10)

t1 = Thread(target=func1, args=(15, 20))
t1.start()
t1.join(5)
#首先 先输出15-20的整数，然后程序暂停5s
t2 = Thread(target=func1, args=(5, 10))
t2.start()
#继续输出整数，t1.join(5)若删去，则并发进行,time.sleep  阻塞当前线程

###########output:
1516171819
56789




注意：
1>进程是资源分配的最小单位,线程是CPU调度的最小单位. 　　　　　
2>每一个进程中至少有一个线程。
3>同一时刻，只能有一个线程.当时考虑的只有一个单核处理器，Python默认加锁，防止数据出现问题
解决防范：多个进程；协程

在多线程版本中，程序员必须写代码来保护共享资源，防止其被多个线程同时访问。
多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题。

事件驱动：
在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。
当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。
回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。
事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。当我们面对如下的环境时，事件驱动模型通常是一个好的选择：
1.	程序中有许多任务，而且…
2.	任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…
3.	在等待事件到来时，某些任务会阻塞。
当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。
网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。

#使用管道实现进程之间的数据交换，适合大量数据的场合
from multiprocessing import Process, Pipe
def f(conn):
    conn.send([42, None, 'hello'])    #向管道中发送数据
    conn.close()                      #关闭管道
 
if __name__ == '__main__':
    parent_conn, child_conn = Pipe()      #创建管道对象
    p = Process(target=f, args=(child_conn,))     #将广岛的一方作为参数传递给子进程
    p.start()
    print(parent_conn.recv())   # prints "[42, None, 'hello']"
    p.join()

传统的编程是如下线性模式的：
开始--->代码块A--->代码块B--->代码块C--->代码块D--->......--->结束
但编程者知道代码块A,B,C,D...的执行顺序，唯一能够改变这个流程的是数据。
输入不同的数据，根据条件语句判断，流程或许就改为A--->C--->E...--->结束。
但它的控制流程是由输入数据和你编写的程序决定的。如果你知道这个程序当前的运行状态（包括输入数据和程序本身）。
那你就知道接下来甚至一直到结束它的运行流程

对于事件驱动型程序模型，它的流程大致如下：
开始--->初始化--->等待
与上面传统编程模式不同，事件驱动程序在启动之后，就在那等待，等待什么呢？等待被事件触发。
       传统编程下也有“等待”的时候，比如在代码块D中，你定义了一个input()，需要用户输入数据。
 但这与下面的等待不同，传统编程的“等待”，比如input()，你作为程序编写者是知道或者强制用户输入某个东西的，
 或许是数字，或许是文件名称，如果用户输入错误，你还需要提醒他，并请他重新输入。事件驱动程序的等待则是完全不知道，
只要某一事件发生，那程序就会做出相应的“反应”。
 这些事件包括：输入信息、鼠标、敲击键盘上某个键还有系统内部定时器触发。
 

创建一个线程循环检测是否有鼠标点击
那么这个方式有以下几个缺点：
       可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？
如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，
由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题； 
所以，该方式是非常不好的。

2 就是事件驱动模型 
目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：

有一个事件（消息）队列；鼠标按下时，往这个队列中增加一个点击事件（消息）；
有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；
事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数； 
事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，
当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。 


通常，我们写服务器处理模型的程序时，有以下几种模型：
（1）每收到一个请求，创建一个新的进程，来处理该请求；
（2）每收到一个请求，创建一个新的线程，来处理该请求；
（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求
上面的几种方式，各有千秋，
第（1）中方法，由于创建新的进程的开销比较大，所以，会导致服务器性能比较差,但实现比较简单。
第（2）种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。
第（3）种方式，在写应用程序代码时，逻辑比前面两种都复杂。
综合考虑各方面因素，一般普遍认为第（3）种方式是大多数网络服务器采用的方式


用户空间与内核空间
进程切换
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。
这种行为被称为进程切换，这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 
从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
保存处理机上下文，包括程序计数器和其他寄存器。更新PCB信息。
把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。选择另一个进程执行，并更新其PCB。更新内存管理的数据结构。

恢复处理机上下文。 
注：总而言之就是很耗资源的

注意，事件驱动的监听事件是由操作系统调用的cpu来完成的

缓存 I/O
缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。
在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，
也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
用户空间没法直接访问内核空间的，内核态到用户态的数据拷贝 

思考：为什么数据一定要先到内核区，直接到用户内存不是更直接吗？
硬件设备如网卡等是操作系统调用的
缓存 I/O 的缺点： 
数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。







