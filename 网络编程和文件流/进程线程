进程:
正在执行中的应用程序，一个进程是一个执行中的文件使用资源的总和，属于动态概念，包括虚拟地址空间，代码，数据，对象句柄，环境变量，执行单元等。
多进程应该避免共享资源。
进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的
多线程的主要作用：充分利用硬件资源，尤其是提高CPU利用率
进程间的数据交换使用Queue对象在进程间交换数据，一个进程把数据放入Queue对象，另一个进程从Queue对象中获取数据。

缺点：
1.进程只能在一个时间干一件事. 2.进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。
如果把我们上课的过程看成一个进程的话，听老师讲课，记笔记，脑子还要思考问题。 上面这三件事将不能同时执行，同一时间只能做一件事.

from multiprocessing import Process, Queue
    multiprocessing包是Python中的多进程管理包。与threading.Thread类似，它可以利用multiprocessing.Process对象来创建一个进程。该进程可以运行在Python程序内部编写的函数。该Process对象与Thread对象的用法相同，也有start(), run(), join()的方法。
此外multiprocessing包中也有Lock/Event/Semaphore/Condition类 (这些对象可以像多线程那样，通过参数传递给各个进程)，用以同步进程，其用法与threading包中的同名类一致。
所以，multiprocessing的很大一部份与threading使用同一套API，只不过换到了多进程的情境。


Procss构造方法：
Process([group [, target [, name [, args [, kwargs]]]]])
　　group: 线程组，目前还没有实现，库引用中提示必须是None； 
　　target: 要执行的方法； 
　　name: 进程名； 
　　args/kwargs: 要传入方法的参数。

实例方法：
　　is_alive()：返回进程是否在运行。
　　join([timeout])：阻塞当前上下文环境的进程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。
　　start()：进程准备就绪，等待CPU调度
　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。
　　terminate()：不管任务是否完成，立即停止工作进程

from multiprocessing import Process
import time
def f(name):
    time.sleep(1)
#time.sleep用于给定时间内挂起(等待)当前线程的执行
#time.sleep通常用于推迟执行的场景
    print('hello', name, time.ctime())

if __name__== '__main__':
    p_list=[]
    for i in range(3):
        p = Process(target=f, args=('alvin',))
        p_list.append(p)            #添加
        p.start()
    for i in p_list:
        p.join()
    print('end')


###########output:
Connected to pydev debugger (build 183.6156.16)
hello alvin Wed Dec 14 16:16:47 2022
hello alvin Wed Dec 14 16:16:48 2022
hello alvin Wed Dec 14 16:16:49 2022
end



from  multiprocessing import Process
import os

def f(name):
  print('module name:', __name__)
#查看父类进程ID
#pid:进程号
  print('parent process',  os.getppid())
  print('process id:', os.getpid())

if __name__=='__main__':
  p=Process(target=f,args=('bob',))
  p.start()    #启动线程
  p.join()     #等待进程运行结束

########output




线程 Threads: 上述进程缺点让我们引入线程这种机制。
解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。

线程调用的两种方法：
1.直接使用Thread类实例化一个线程对象并传递一个可调用对象作为参数
2.继承Tread类并在派生类重写__init__()和run()方法。
import threading
import time
　　
class MyThread(threading.Thread):
    def __init__(self,num):
        threading.Thread.__init__(self)
        self.num = num
 
    def run(self):#定义每个线程要运行的函数
 
        print("running on number:%s" %self.num)
 
        time.sleep(3)
 
if __name__ == '__main__':
 
    t1 = MyThread(1)
    t2 = MyThread(2)
    t1.start()
    t2.start()

########output:
running on number:1
running on number:2


from threading import Thread
import time
def func1(x, y):
    for i in range(x, y):
        print(i, end='')
    print()
    time.sleep(10)

t1 = Thread(target=func1, args=(15, 20))
t1.start()
t1.join(5)
#首先 先输出15-20的整数，然后程序暂停5s
t2 = Thread(target=func1, args=(5, 10))
t2.start()
#继续输出整数，t1.join(5)若删去，则并发进行,time.sleep  阻塞当前线程

###########output:
1516171819
56789




注意：
1>进程是资源分配的最小单位,线程是CPU调度的最小单位. 　　　　　
2>每一个进程中至少有一个线程。
3>同一时刻，只能有一个线程.当时考虑的只有一个单核处理器，Python默认加锁，防止数据出现问题
解决防范：多个进程；协程

在多线程版本中，程序员必须写代码来保护共享资源，防止其被多个线程同时访问。
多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题。

事件驱动：
在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。
当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。
回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。
事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。当我们面对如下的环境时，事件驱动模型通常是一个好的选择：
1.	程序中有许多任务，而且…
2.	任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…
3.	在等待事件到来时，某些任务会阻塞。
当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。
网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。

#使用管道实现进程之间的数据交换，适合大量数据的场合
from multiprocessing import Process, Pipe
def f(conn):
    conn.send([42, None, 'hello'])    #向管道中发送数据
    conn.close()                      #关闭管道
 
if __name__ == '__main__':
    parent_conn, child_conn = Pipe()      #创建管道对象
    p = Process(target=f, args=(child_conn,))     #将广岛的一方作为参数传递给子进程
    p.start()
    print(parent_conn.recv())   # prints "[42, None, 'hello']"
    p.join()
	
